Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 securityonion-squert (20161212-1ubuntu1securityonion24) trusty; urgency=medium
 .
   * improve callback.php and grant permission to autocat table
Author: Doug Burks <doug.burks@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- securityonion-squert-20161212.orig/.inc/callback.php
+++ securityonion-squert-20161212/.inc/callback.php
@@ -9,14 +9,12 @@ if (!(isset($_SESSION['sLogin']) && $_SE
 $base = dirname(__FILE__);
 include_once "$base/config.php";
 include_once "$base/functions.php";
-// original database connection info
-$link = mysql_connect($dbHost,$dbUser,$dbPass);
-$db = mysql_select_db($dbName,$link);
 // PDO prepared statements
 try {
 	// first connect to database with the PDO object. 
-	$dbpdo = new PDO("mysql:host=$dbHost;dbname=$dbName;charset=utf8", "$dbUser", "$dbPass", [
+	$dbpdo = new PDO("mysql:host=$dbHost;dbname=$dbName;charset=latin1", "$dbUser", "$dbPass", [
 	PDO::ATTR_EMULATE_PREPARES => false, 
+	PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => false,
 	PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
 	]); 
 } catch(PDOException $e){
@@ -53,12 +51,10 @@ $types = array(
 );
 
 $type = $types[$type];
-//error_log("type is $type");
 
 if (isset($_REQUEST['ts'])) {
   // Need EC
-  $tsParts = explode("|", mysql_real_escape_string(hextostr($_REQUEST['ts'])));
-  //$tsParts = explode("|", hextostr($_REQUEST['ts']));
+  $tsParts = explode("|", hextostr($_REQUEST['ts']));
   $sdate  = $tsParts[0]; 
   $edate  = $tsParts[1];
   $stime  = $tsParts[2];
@@ -74,13 +70,14 @@ if (isset($_REQUEST['ts'])) {
 }
 
 // user can specify sensors
+$sensors = '';
+$sensorsclean = '';
+$in = '';
+$sensor_params = array();
 if (isset($_REQUEST['sensors'])) {
   $sensors = hextostr($_REQUEST['sensors']);
   if ($sensors == 'empty') {
     $sensors = '';
-    $sensorsclean = '';
-    $in = '';
-    $sensor_params = array();
   } else {
     // $sensors looks like this:
     // AND event.sid IN('3','1')
@@ -91,7 +88,6 @@ if (isset($_REQUEST['sensors'])) {
     // now we need to dynamically build IN for prepared statement based on:
     // https://phpdelusions.net/pdo#like
     $ids = explode(",", $sensorsclean);
-    $in = "";
     foreach ($ids as $i => $item)
     {
       $key = ":id".$i;
@@ -103,13 +99,89 @@ if (isset($_REQUEST['sensors'])) {
   }
 }
 
-// rt is the queue-only toggle on the left
-if (isset($_REQUEST['rt'])) {
-  $rt = $_REQUEST['rt'];
-  if ($rt == 1) {
-    $rt = "AND event.status = 0";
+// rt is the queue-only toggle on the left side of the EVENTS tab
+$rt = "";
+if (isset($_REQUEST['rt']) && $_REQUEST['rt'] == 1) {
+  $rt = "AND event.status = 0";
+}
+
+// $sv is for sorting.  For example: DESC
+// this cannot be done via prepared statement, so we use a whitelist approach
+$sv = "";
+if (isset($_REQUEST['sv'])) {
+  $sv = $_REQUEST['sv'] == 'DESC' ? 'DESC' : 'ASC';
+}
+
+// many functions below rely on filters so let's build that out now
+if (isset($_REQUEST['filter'])) {
+  $filter = hextostr($_REQUEST['filter']);
+  // $filter comes from the filter box in the upper right corner of the EVENTS tab.  Default: empty
+  if ($filter != 'empty') {
+    if (substr($filter, 0,4) == 'cmt ') {
+      // user entered cmt into the filter box
+      // pull their filter out and place it into the prepared statement array
+      $comment = explode('cmt ', $filter);
+      $filtercmt = $comment[1];
+      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid 
+                WHERE history.comment = :filtercmt";
+      // build parameters for prepared statement
+      $qp2_params = [":filtercmt" => "$filtercmt"];
+    } else {
+      // if the user didn't enter cmt, then they may be using one of the built-in filters
+      // for example, if the user wants to search for alerts with src or dst ip in US:
+      // cc us
+      // we'll then receive the following:
+      // (msrc.cc = 'us' OR mdst.cc = 'us')
+      // the general strategy is to try to match this with one of the built-in filters to ensure validity
+      // then build a prepared statement
+      // this needs to be fixed
+      $filter = str_replace('&lt;','<', $filter);
+      $filter = str_replace('&gt;','>', $filter);
+      // build parameters for prepared statement
+      $qp2_params = [":sdatetime" => "$sdatetime", ":edatetime" => "$edatetime", ":soffset" => "$offset", ":eoffset" => "$offset"];
+      // find whatever is enclosed in single ticks and replace with $
+      $exploded=explode("'",$filter);
+      $filtervar=$exploded[1];
+      $compfilter = str_replace($filtervar, '$', $filter);
+      // retrieve all valid filters from database
+      $statement="SELECT UNHEX(filter) from filters where type='filter';";
+      $query = $dbpdo->prepare("$statement");
+      $query->execute();
+      $rows = $query->fetchAll(PDO::FETCH_BOTH);
+      // search for user filter in list of valid filters
+      $newfilter = "";
+      $filter = "";
+      // "signature LIKE" is a special case
+      if ( "$compfilter" == "(signature LIKE '$' OR signature LIKE '$')" ) {
+        $filter = "AND (signature LIKE :filtervar1 OR signature LIKE :filtervar2)";
+        $qp2_params[":filtervar1"] = "%$filtervar%";
+        $qp2_params[":filtervar2"] = "%$filtervar%";
+      } else {
+        foreach ($rows as $row) {
+          if ( "$compfilter" == "$row[0]" ) {
+            $newfilter = $row[0];
+            $i=0;
+            while (strpos($newfilter, "'\$'") !== false) {
+              $newfilter = preg_replace('/\'\$\'/', ":filtervar$i", "$newfilter", 1);
+              $qp2_params[":filtervar$i"] = $filtervar;
+              $i++;
+            }
+            $filter = "AND " . $newfilter;
+          }
+        }
+      }
+      $qp2 = "WHERE event.timestamp BETWEEN CONVERT_TZ(:sdatetime,:soffset,'+00:00') AND CONVERT_TZ(:edatetime,:eoffset,'+00:00')
+        $sensors
+        $filter
+        $rt";
+    }
   } else {
-    $rt = "";
+    // filter box was empty so we'll just build a prepared statement using sensors and rt values
+    $qp2 = "WHERE event.timestamp BETWEEN CONVERT_TZ(:sdatetime,:soffset,'+00:00') AND CONVERT_TZ(:edatetime,:eoffset,'+00:00')
+      $sensors
+      $rt";
+    // build parameters for prepared statement
+    $qp2_params = [":sdatetime" => "$sdatetime", ":edatetime" => "$edatetime", ":soffset" => "$offset", ":eoffset" => "$offset"];
   }
 }
 
@@ -119,7 +191,7 @@ if (!$type) {
 
 function ec() {
   // This function returns event count grouped by status.
-  // This is used to populate the numbers in the Classification section on the left side of the Events tab.
+  // This is used to populate the numbers in the Classification section on the left side of the EVENTS tab.
   // This function has been updated to use PDO prepared statements.
   global $sdatetime, $edatetime, $offset, $sensors, $sensor_params, $dbpdo;
 
@@ -212,73 +284,9 @@ function signatures() {
 }
 
 function level0() {   
+  // This function returns the aggegrated event data in the main section of the EVENTS tab.
   // This function has been updated to use PDO prepared statements.
-  global $offset, $when, $sensors, $rt, $sdatetime, $edatetime, $sensorsclean, $sensor_params, $dbpdo;
-  // $sv is for sorting.  For example: DESC
-  // this cannot be done via prepared statement, so we use a whitelist approach
-  $sv = mysql_real_escape_string($_REQUEST['sv']) == 'DESC' ? 'DESC' : 'ASC';
-  $filter = hextostr($_REQUEST['filter']);
-  // $filter comes from the filter box in the upper right corner of the Events tab.  Default: empty
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      // user entered cmt into the filter box
-      // pull their filter out and place it into the prepared statement array
-      $comment = explode('cmt ', $filter);
-      $filtercmt = mysql_real_escape_string($comment[1]);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid 
-	        WHERE history.comment = :filtercmt";
-      // build parameters for prepared statement
-      $params = [":sdatetime" => "$sdatetime", ":edatetime" => "$edatetime", ":soffset" => "$offset", ":eoffset" => "$offset", ":maxoffset" => "$offset", ":groupoffset" => "$offset", ":filtercmt" => "$filtercmt"];
-    } else {
-      // if the user didn't enter cmt, then they may be using one of the built-in filters
-      // for example, if the user wants to search for alerts with src or dst ip in US:
-      // cc us
-      // we'll then receive the following:
-      // (msrc.cc = 'us' OR mdst.cc = 'us')
-      // the general strategy is to try to match this with one of the built-in filters to ensure validity
-      // then build a prepared statement
-      // this needs to be fixed
-      $filter = str_replace('&lt;','<', $filter);
-      $filter = str_replace('&gt;','>', $filter);
-      // build parameters for prepared statement
-      $params = [":sdatetime" => "$sdatetime", ":edatetime" => "$edatetime", ":soffset" => "$offset", ":eoffset" => "$offset", ":maxoffset" => "$offset", ":groupoffset" => "$offset"];
-      // find whatever is enclosed in single ticks and replace with $
-      $exploded=explode("'",$filter);
-      $filtervar=$exploded[1];
-      $compfilter = str_replace($filtervar, '$', $filter);
-      // retrieve all valid filters from database
-      $statement="SELECT UNHEX(filter) from filters where type='filter';";
-      $query = $dbpdo->prepare("$statement");
-      $query->execute();
-      $rows = $query->fetchAll(PDO::FETCH_BOTH);
-      // search for user filter in list of valid filters
-      $newfilter = "";
-      foreach ($rows as $row) {
-        if ( "$compfilter" == "$row[0]" ) {
-          $newfilter = $row[0];
-          $i=0;
-          while (strpos($newfilter, "'\$'") !== false) {
-            $newfilter = preg_replace('/\'\$\'/', ":filtervar$i", "$newfilter", 1);
-            $params[":filtervar$i"] = $filtervar;
-            $i++;
-          }
-          $filter = "AND " . $newfilter;
-        }
-      }
-      $qp2 = "WHERE event.timestamp BETWEEN CONVERT_TZ(:sdatetime,:soffset,'+00:00') AND CONVERT_TZ(:edatetime,:eoffset,'+00:00')
-        $sensors
-        $filter
-        $rt";
-    }
-  } else {
-    // filter box was empty so we'll just build a prepared statement using sensors and rt values
-    $qp2 = "WHERE event.timestamp BETWEEN CONVERT_TZ(:sdatetime,:soffset,'+00:00') AND CONVERT_TZ(:edatetime,:eoffset,'+00:00')
-      $sensors
-      $rt";
-    // build parameters for prepared statement
-    $params = [":sdatetime" => "$sdatetime", ":edatetime" => "$edatetime", ":soffset" => "$offset", ":eoffset" => "$offset", ":maxoffset" => "$offset", ":groupoffset" => "$offset"];
-  }
-
+  global $offset, $when, $sensors, $rt, $sdatetime, $edatetime, $sensor_params, $dbpdo, $qp2, $qp2_params, $sv;
   // build statement
   $statement="SELECT COUNT(event.signature) AS f1,
     event.signature AS f2,
@@ -303,12 +311,18 @@ function level0() {
     $qp2
     GROUP BY f3
     ORDER BY f5 $sv";
-  // debug
-  //error_log("$statement");
+  // add params for local part of statement
+  $local_params[':maxoffset'] = "$offset";
+  $local_params[':groupoffset'] = "$offset";
   // prepare statement
   $query = $dbpdo->prepare("$statement");
-  // execute the prepared statement and pass it the local params array and the sensor_params array
-  $query->execute(array_merge($params,$sensor_params));
+  // merge params
+  $merged_params = array_merge($local_params, $sensor_params, $qp2_params);
+  // debug
+  //error_log("statement: $statement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $query->execute($merged_params);
   // fetch the data and encode to json
   $rows = $query->fetchAll(PDO::FETCH_ASSOC);
   $theJSON = json_encode($rows);
@@ -316,39 +330,18 @@ function level0() {
 }
 
 function level1() {
-
-  global $offset, $when, $sensors, $rt;
-  $sid = mysql_real_escape_string($_REQUEST['object']);
-  $sv = mysql_real_escape_string($_REQUEST['sv']);
-  $filter = hextostr($_REQUEST['filter']);
-
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      $comment = explode('cmt ', $filter);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid 
-        WHERE history.comment = '" . mysql_real_escape_string($comment[1]) . "'
-        AND event.signature_id = '$sid'";
-    } else {
-      // this needs to be fixed
-      $filter = str_replace('&lt;','<', $filter);
-      $filter = str_replace('&gt;','>', $filter);
-      $filter = "AND " . $filter;
-      $qp2 = "WHERE $when
-        $sensors
-        AND event.signature_id = '$sid'
-        $filter
-        $rt";
-    }
-  } else {
-    $qp2 = "WHERE $when
-      $sensors
-      AND event.signature_id = '$sid'
-      $rt";
-  }
-
-  // LEVEL 1
-  $query = "SELECT COUNT(event.signature) AS count,
-    MAX(CONVERT_TZ(event.timestamp,'+00:00','$offset')) AS maxTime,
+  // This function is called when the user clicks a number in the Queue column to drill into a group of aggregated events.
+  // This function has been updated to use PDO prepared statements.
+  global $offset, $when, $sensors, $rt, $sdatetime, $edatetime, $sensor_params, $dbpdo, $qp2, $qp2_params, $sv;
+  // sid is signature_id (snort/suricata ID, OSSEC rule ID, etc.)
+  $sid = $_REQUEST['object'];
+  // add sid to $qp2 and $qp2_params
+  $qp2 = "$qp2
+    AND event.signature_id = :sid";
+  $qp2_params[':sid'] = "$sid";
+  // build statement
+  $statement = "SELECT COUNT(event.signature) AS count,
+    MAX(CONVERT_TZ(event.timestamp,'+00:00', :maxoffset)) AS maxTime,
     INET_NTOA(event.src_ip) AS src_ip,
     msrc.c_long AS src_cc,
     INET_NTOA(event.dst_ip) AS dst_ip,
@@ -360,8 +353,8 @@ function level1() {
     GROUP_CONCAT(event.sid) AS c_sid,
     GROUP_CONCAT(event.cid) AS c_cid,
     GROUP_CONCAT(event.status) AS c_status,
-    GROUP_CONCAT(SUBSTR(CONVERT_TZ(event.timestamp,'+00:00','$offset'),12,5)) AS c_ts,
-    GROUP_CONCAT(SUBSTRING(CONVERT_TZ(event.timestamp, '+00:00', '$offset'),12,2)) AS f12,
+    GROUP_CONCAT(SUBSTR(CONVERT_TZ(event.timestamp,'+00:00', :groupoffset1),12,5)) AS c_ts,
+    GROUP_CONCAT(SUBSTRING(CONVERT_TZ(event.timestamp, '+00:00', :groupoffset2),12,2)) AS f12,
     event.priority AS f13,
     msrc.age AS src_age,
     mdst.age AS dst_age,
@@ -377,58 +370,46 @@ function level1() {
     $qp2
     GROUP BY event.src_ip, event.dst_ip
     ORDER BY maxTime $sv";
-
-  $result = mysql_query($query);
-
-  $rows = array();
-
-  while ($row = mysql_fetch_assoc($result)) {
-    $rows[] = $row;
-  }
+  // add params for local part of statement
+  $local_params[':maxoffset'] = "$offset";
+  $local_params[':groupoffset1'] = "$offset";
+  $local_params[':groupoffset2'] = "$offset";
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // merge params
+  $merged_params = array_merge($local_params, $sensor_params, $qp2_params);
+  // debug
+  //error_log("statement: $statement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $query->execute($merged_params);
+  // fetch the data and encode to json
+  $rows = $query->fetchAll(PDO::FETCH_ASSOC);
   $theJSON = json_encode($rows);
   echo $theJSON;
 }
 
 function level2() {
-
-  global $offset, $when, $sensors, $rt;
-  $comp = mysql_real_escape_string($_REQUEST['object']);
-  $filter = hextostr($_REQUEST['filter']);
-  $sv = mysql_real_escape_string($_REQUEST['sv']);
-  $adqp = mysql_real_escape_string(hextostr($_REQUEST['adqp']));
+  // This function is called when the user clicks a number in the Queue column in the second level of aggregation.
+  // This function has been updated to use PDO prepared statements.
+  global $offset, $when, $sensors, $rt, $qp2, $qp2_params, $sensor_params, $sv, $dbpdo;
+  $comp = $_REQUEST['object'];
   list($ln,$sid,$src_ip,$dst_ip) = explode("-", $comp);
   $src_ip = sprintf("%u", ip2long($src_ip));
   $dst_ip = sprintf("%u", ip2long($dst_ip));
 
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      $comment = explode('cmt ', $filter);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid 
-        WHERE history.comment = '" . mysql_real_escape_string($comment[1]) . "'
-        AND (event.signature_id = '$sid'
-        AND event.src_ip = '$src_ip'
-        AND event.dst_ip = '$dst_ip')";
-    } else {
-      $qp2 = "WHERE $when
-        $sensors
-        AND (event.signature_id = '$sid' 
-        AND event.src_ip = '$src_ip' 
-        AND event.dst_ip = '$dst_ip')";
-    }
-  } else {
-    if ($adqp === "empty") {
-      $adqp = "";
-    }
-    $qp2 = "WHERE $when
-      $sensors
-      $adqp
-      AND (event.signature_id = '$sid' 
-      AND event.src_ip = '$src_ip' 
-      AND event.dst_ip = '$dst_ip')";
-  }
-
-  $query = "SELECT event.status AS f1, 
-    CONCAT_WS(',',CONVERT_TZ(event.timestamp,'+00:00','$offset'),event.timestamp) AS f2,
+  // add sid, src_ip, and dst_ip to $qp2 and $qp2_params
+  $qp2 = "$qp2
+      AND (event.signature_id = :sid 
+      AND event.src_ip = :src_ip 
+      AND event.dst_ip = :dst_ip)";
+  $qp2_params[':sid'] = "$sid";
+  $qp2_params[':src_ip'] = "$src_ip";
+  $qp2_params[':dst_ip'] = "$dst_ip";
+
+  // build statement using $qp2
+  $statement = "SELECT event.status AS f1, 
+    CONCAT_WS(',',CONVERT_TZ(event.timestamp,'+00:00',:concatoffset),event.timestamp) AS f2,
     INET_NTOA(event.src_ip) AS f3,
     event.src_port AS f4,
     INET_NTOA(event.dst_ip) AS f5,
@@ -445,50 +426,34 @@ function level2() {
     LEFT JOIN object_mappings AS src_tag ON event.src_ip = src_tag.object AND src_tag.type = 'tag'
     LEFT JOIN object_mappings AS dst_tag ON event.dst_ip = dst_tag.object AND dst_tag.type = 'tag'
     $qp2
-    $rt
     GROUP BY event.sid,event.cid
     ORDER BY event.timestamp $sv";
 
-  $result = mysql_query($query);
-  $rows = array();
-
-  while ($row = mysql_fetch_assoc($result)) {
-    $rows[] = $row;
-  }
+  // add params for local part of statement
+  $local_params[':concatoffset'] = "$offset";
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // merge params
+  $merged_params = array_merge($local_params, $sensor_params, $qp2_params);
+  // debug
+  //error_log("statement: $statement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $query->execute($merged_params);
+  // fetch the data and encode to json
+  $rows = $query->fetchAll(PDO::FETCH_ASSOC);
   $theJSON = json_encode($rows);
   echo $theJSON;
 
 }
 
 function level2a() {
-
-  global $offset, $when, $sensors, $rt;
-  $sv = mysql_real_escape_string($_REQUEST['sv']);
-  $filter = hextostr($_REQUEST['filter']);
-
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      $comment = explode('cmt ', $filter);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid 
-        WHERE history.comment = '" . mysql_real_escape_string($comment[1]) . "'";
-    } else {
-      // this needs to be fixed...
-      $filter = str_replace('&lt;','<', $filter);
-      $filter = str_replace('&gt;','>', $filter);
-      $filter = "AND " . $filter;
-      $qp2 = "WHERE $when
-        $sensors
-        $filter
-        $rt";
-    }
-  } else {
-    $qp2 = "WHERE $when
-      $sensors
-      $rt";
-  }
-
-  $query = "SELECT event.status AS f1, 
-    CONCAT_WS(',',CONVERT_TZ(event.timestamp,'+00:00','$offset'),event.timestamp) AS f2,
+  // This function is called when grouping is turned off.
+  // This function has been updated to use PDO prepared statements.
+  global $offset, $when, $sensors, $rt, $qp2, $qp2_params, $sensor_params, $sv, $dbpdo;
+  // build statement
+  $statement = "SELECT event.status AS f1, 
+    CONCAT_WS(',',CONVERT_TZ(event.timestamp,'+00:00',:concatoffset),event.timestamp) AS f2,
     INET_NTOA(event.src_ip) AS f3,
     event.src_port AS f4, 
     msrc.c_long AS f5,
@@ -516,30 +481,39 @@ function level2a() {
     $qp2
     GROUP BY event.sid, event.cid
     ORDER BY event.timestamp $sv";
-
-  $result = mysql_query($query);
-  $rows = array();
-  while ($row = mysql_fetch_assoc($result)) {
-    $rows[] = $row;
-  }
+  // add params for local part of statement
+  $local_params[':concatoffset'] = "$offset";
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // merge params
+  $merged_params = array_merge($local_params, $sensor_params, $qp2_params);
+  // debug
+  //error_log("statement: $statement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $query->execute($merged_params);
+  // fetch the data and encode to json
+  $rows = $query->fetchAll(PDO::FETCH_ASSOC);
   $theJSON = json_encode($rows);
   echo $theJSON;
 }
 
 function payload() {
+  // This function retrieves the payload of the event.
+  // This function has been updated to use PDO prepared statements.
 
-  global $offset;
-  $comp = mysql_real_escape_string($_REQUEST['object']);
+  global $offset, $dbpdo;
+  $comp = $_REQUEST['object'];
   list($sid,$cid) = explode("-", $comp);
 
-  $query = "SELECT INET_NTOA(event.src_ip), 
+  $statement = "SELECT INET_NTOA(event.src_ip), 
               INET_NTOA(event.dst_ip),
               event.ip_ver, event.ip_hlen, event.ip_tos,
               event.ip_len, event.ip_id, event.ip_flags,
               event.ip_off, event.ip_ttl, event.ip_csum,
               event.src_port, event.dst_port, event.ip_proto,
               event.signature, event.signature_id,
-              CONVERT_TZ(event.timestamp,'+00:00','$offset'), event.sid, event.cid,
+              CONVERT_TZ(event.timestamp,'+00:00', :offset), event.sid, event.cid,
               GROUP_CONCAT(history.comment SEPARATOR ' || ') AS comment,
               GROUP_CONCAT(src_tag.value) AS srctag,
               GROUP_CONCAT(dst_tag.value) AS dsttag
@@ -547,21 +521,28 @@ function payload() {
               LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid
               LEFT JOIN object_mappings AS src_tag ON event.src_ip = src_tag.object AND src_tag.type = 'tag'
               LEFT JOIN object_mappings AS dst_tag ON event.dst_ip = dst_tag.object AND dst_tag.type = 'tag'
-              WHERE event.sid='$sid' AND event.cid='$cid'";
-
-  $result = mysql_query($query);
-
+              WHERE event.sid=:sid AND event.cid=:cid";
+  // debug
+  //error_log("$statement");
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // build parameters for prepared statement
+  $params = [":offset" => "$offset", ":sid" => "$sid", ":cid" => "$cid"];
+  // execute the prepared statement with params
+  $query->execute(array_merge($params));
+  // fetch the data
+  $row = $query->fetchall(PDO::FETCH_ASSOC);
   $rows = array();
-
-  $row = mysql_fetch_assoc($result);
-  $rows[] = $row;
-  $ipp = $row["ip_proto"];
+  if (array_key_exists(0, $row)) {
+    $rows[] = $row[0];
+  }
+  $ipp = $row[0]["ip_proto"];
 
   // Protocol
   switch ($ipp) {
 
   case 1:
-    $query = "SELECT event.icmp_type AS icmp_type,
+    $statement = "SELECT event.icmp_type AS icmp_type,
       event.icmp_code AS icmp_code,
       icmphdr.icmp_csum AS icmp_csum, 
       icmphdr.icmp_id AS icmp_id,
@@ -569,54 +550,78 @@ function payload() {
       FROM event, icmphdr
       WHERE event.sid=icmphdr.sid
       AND event.cid=icmphdr.cid
-      AND event.sid='$sid'
-      AND event.cid='$cid'";
-
-    $result = mysql_query($query);
-
-    $row = mysql_fetch_assoc($result);
-    $rows[] = $row;
+      AND event.sid=:sid
+      AND event.cid=:cid";
+    // debug
+    //error_log("$statement");
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // build parameters for prepared statement
+    $params = [":sid" => "$sid", ":cid" => "$cid"];
+    // execute the prepared statement with params
+    $query->execute(array_merge($params));
+    // fetch the data
+    $row = $query->fetchall(PDO::FETCH_ASSOC);
+    if (array_key_exists(0, $row)) {
+      $rows[] = $row[0];
+    }
     break;
 
   case 6:
-    $query = "SELECT tcp_seq, tcp_ack, tcp_off, tcp_res, tcp_flags, tcp_win, tcp_urp, tcp_csum
+    $statement = "SELECT tcp_seq, tcp_ack, tcp_off, tcp_res, tcp_flags, tcp_win, tcp_urp, tcp_csum
       FROM tcphdr 
-      WHERE sid='$sid' AND cid='$cid'";
-
-    $result = mysql_query($query);
-
-    $row = mysql_fetch_assoc($result);
-    $rows[] = $row;
+      WHERE sid=:sid AND cid=:cid";
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // build parameters for prepared statement
+    $params = [":sid" => "$sid", ":cid" => "$cid"];
+    // execute the prepared statement with params
+    $query->execute(array_merge($params));
+    // fetch the data
+    $row = $query->fetchall(PDO::FETCH_ASSOC);
+    if (array_key_exists(0, $row)) {
+      $rows[] = $row[0];
+    }
     break;
 
   case 17:
-    $query = "SELECT udp_len, udp_csum 
+    $statement = "SELECT udp_len, udp_csum 
       FROM udphdr 
-      WHERE sid='$sid' AND cid='$cid'";
-
-    $result = mysql_query($query);
-
-    $row = mysql_fetch_assoc($result);
-    $rows[] = $row;
+      WHERE sid=:sid AND cid=:cid";
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // build parameters for prepared statement
+    $params = [":sid" => "$sid", ":cid" => "$cid"];
+    // execute the prepared statement with params
+    $query->execute(array_merge($params));
+    // fetch the data
+    $row = $query->fetchall(PDO::FETCH_ASSOC);
+    if (array_key_exists(0, $row)) {
+      $rows[] = $row[0];
+    }
     break;
   default:
     $result = array(0 => 0);
     $rows[] = $row;
     break;
   }
-
   // Data
-  $query = "SELECT data_payload 
+  $statement = "SELECT data_payload 
     FROM data 
-    WHERE sid='$sid' AND cid='$cid'";
-
-  $result = mysql_query($query);
-
-  $row = mysql_fetch_assoc($result);
-  $rows[] = $row;
+    WHERE sid=:sid AND cid=:cid";
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // build parameters for prepared statement
+  $params = [":sid" => "$sid", ":cid" => "$cid"];
+  // execute the prepared statement with params
+  $query->execute(array_merge($params));
+  // fetch the data and encode to json
+  $row = $query->fetchall(PDO::FETCH_ASSOC);
+  if (array_key_exists(0, $row)) {
+    $rows[] = $row[0];
+  }
   $theJSON = json_encode($rows);
   echo $theJSON;
-
 }
 
 function tab() {
@@ -630,21 +635,28 @@ function transcript() {
 }
 
 function filters() {   
+  // This function queries and updates the filters table.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
   $user = $_SESSION['sUser'];
-  $mode = mysql_real_escape_string($_REQUEST['mode']);
+  $mode = $_REQUEST['mode'];
 
   switch ($mode) {
   case "query"  : 
-    $query = "SELECT type, UNHEX(name) AS name, alias, filter, UNHEX(notes) as notes, age, global, username
+    $statement = "SELECT type, UNHEX(name) AS name, alias, filter, UNHEX(notes) as notes, age, global, username
       FROM filters 
       ORDER BY global,name ASC";
 
-    $result = mysql_query($query);
-
     $rows = array();
 
+    // debug
+    //error_log("$statement");
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // execute the prepared statement with params
+    $query->execute();
     # iterate through each row of the filter table
-    while ($row = mysql_fetch_assoc($result)) {
+    while ($row = $query->fetch(PDO::FETCH_ASSOC)) {
 	# for each field in that row, we need to sanitize before output
 	foreach ($row as &$value) {
 		# https://paragonie.com/blog/2015/06/preventing-xss-vulnerabilities-in-php-everything-you-need-know
@@ -670,23 +682,50 @@ function filters() {
     $filter = str_ireplace($remove, "", $filter);
     $filter = strtohex($filter);
 
-    $query = "INSERT INTO filters (type,name,alias,username,filter,notes)
-      VALUES ('$type','$name','$alias','$user','$filter','$notes')
+    $statement = "INSERT INTO filters (type,name,alias,username,filter,notes)
+      VALUES (:type1,:name1,:alias1,:user1,:filter1,:notes1)
       ON DUPLICATE KEY UPDATE 
-      type='$type',name='$name',alias='$alias',filter='$filter',notes='$notes'";
+      type=:type2,name=:name2,alias=:alias2,filter=:filter2,notes=:notes2";
+    // debug
+    //error_log("$statement");
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // build parameters for prepared statement
+    $params = [":type1" => "$type", ":name1" => "$name", ":alias1" => "$alias", ":user1" => "$user", ":filter1" => "$filter", ":notes1" => "$notes", ":type2" => "$type", ":name2" => "$name", ":alias2" => "$alias", ":filter2" => "$filter", ":notes2" => "$notes"];
+    // execute the prepared statement with params
+    $query->execute(array_merge($params));
+    // check for errors
+    $error = $query->errorInfo();
+    $result = "";
+    // if there was no error, then $error[2] should be null
+    if ( ! is_null($error[2]) ) {
+      $result = $error[2];
+    }
 
-    mysql_query($query);
-    $result = mysql_error();
     $return = array("msg" => $result);
     $theJSON = json_encode($return);
 
     break;
 
   case "remove" : 
-    $alias =  mysql_real_escape_string($_REQUEST['data']);  
-    $query = "DELETE FROM filters WHERE username = '$user' AND (alias = '$alias' AND global = 0)";
-    mysql_query($query);
-    $result = mysql_error();
+    $alias = $_REQUEST['data'];
+    $statement = "DELETE FROM filters WHERE username = :user AND (alias = :alias AND global = 0)";
+    // debug
+    //error_log("$statement");
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // build parameters for prepared statement
+    $params = [":user" => "$user", ":alias" => "$alias"];
+    // execute the prepared statement with the params
+    $query->execute(array_merge($params));
+    // check for errors
+    $error = $query->errorInfo();
+    $result = "";
+    // if there was no error, then $error[2] should be null
+    if ( ! is_null($error[2]) ) {
+      $result = $error[2];
+    }
+
     $return = array("msg" => $result);
     $theJSON = json_encode($return); 
 
@@ -732,7 +771,10 @@ function cat() {
 }
 
 function comments() {
-  $query = "SELECT COUNT(comment) AS f1,
+  // This function retrieves comments from the history table.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
+  $statement = "SELECT COUNT(comment) AS f1,
     comment AS f2,
     u.username AS f3,
     MIN(timestamp) AS f4,
@@ -745,53 +787,52 @@ function comments() {
     AND (comment NOT IN('NULL','Auto Update','') AND comment NOT LIKE ('autoid %'))
     GROUP BY comment
     ORDER BY f5 DESC";
-
-  $result = mysql_query($query);
-  $rows = array();
-
-  while ($row = mysql_fetch_assoc($result)) {
-    $rows[] = $row;
-  }
+  // debug
+  //error_log("$statement");
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // execute the prepared statement
+  $query->execute();
+  // fetch the data and encode to json
+  $rows = $query->fetchAll(PDO::FETCH_ASSOC);
   $theJSON = json_encode($rows);
   echo $theJSON;
 }
 
 function remove_comment() {   
+  // This function removes a comment from the history table.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
   $user = $_SESSION['sUser'];
   $comment = hextostr($_REQUEST['comment']);
-  $comment = mysql_real_escape_string($comment);
-  $query = "DELETE FROM history WHERE comment = '$comment'";
-  mysql_query($query);
-  $result = mysql_error();
+  $comment = $comment;
+  $statement = "DELETE FROM history WHERE comment = :comment";
+  // debug
+  //error_log("$statement");
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // build parameters for prepared statement
+  $params = [":comment" => "$comment"];
+  // execute the prepared statement with the params
+  $query->execute(array_merge($params));
+  // check for errors
+  $error = $query->errorInfo();
+  $result = "";
+  // if there was no error, then $error[2] should be null
+  if ( ! is_null($error[2]) ) {
+    $result = $error[2];
+  }
   $return = array("msg" => $result);
-
   $theJSON = json_encode($return); 
   echo $theJSON;
 }
 
 function map() {
-  global $when, $sensors;
-  $filter  = hextostr($_REQUEST['filter']);
-
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      $comment = explode('cmt ', $filter);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid
-        WHERE history.comment = '$comment[1]'";
-    } else {
-      $filter = str_replace('&lt;','<', $filter);
-      $filter = str_replace('&gt;','>', $filter);
-      $filter = "AND " . $filter;
-      $qp2 = "WHERE $when
-        $sensors
-        $filter";
-    }
-  } else {
-    $qp2 = "WHERE $when
-      $sensors";
-  }
+  // This function is called when the user clicks the SUMMARY tab.
+  // This function has been updated to use PDO prepared statements.
 
-  $srcq = "SELECT COUNT(src_ip) AS c, msrc.cc 
+  global $when, $sensors, $qp2, $qp2_params, $sensor_params, $sv, $dbpdo;
+  $srcstatement = "SELECT COUNT(src_ip) AS c, msrc.cc 
     FROM event
     LEFT JOIN mappings AS msrc ON event.src_ip = msrc.ip
     LEFT JOIN mappings AS mdst ON event.dst_ip = mdst.ip 
@@ -803,7 +844,7 @@ function map() {
     GROUP BY msrc.cc
     ORDER BY c DESC";
 
-  $dstq = "SELECT COUNT(dst_ip) AS c, mdst.cc 
+  $dststatement = "SELECT COUNT(dst_ip) AS c, mdst.cc 
     FROM event
     LEFT JOIN mappings AS msrc ON event.src_ip = msrc.ip
     LEFT JOIN mappings AS mdst ON event.dst_ip = mdst.ip 
@@ -814,16 +855,23 @@ function map() {
     AND mdst.cc IS NOT NULL
     GROUP BY mdst.cc
     ORDER BY c DESC";
-
-  $srcr = mysql_query($srcq);
-  $dstr = mysql_query($dstq);
+  // prepare statements
+  $srcquery = $dbpdo->prepare("$srcstatement");
+  // merge params
+  $merged_params = array_merge($sensor_params, $qp2_params);
+  // debug
+  //error_log("srcstatement: $srcstatement");
+  //error_log("dststatement: $dststatement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $srcquery->execute($merged_params);
 
   // A => src, B=> dst,  C=> cumulative
   $a1 = $a2 = $b1 = $b2 = array();
   $aHit = $bHit = $cHit = 'no';
 
   // Source countries and count
-  while ($row = mysql_fetch_row($srcr)) {
+  while ($row = $srcquery->fetch(PDO::FETCH_NUM)) {
     $a1[] = $row[0];
     $a2[] = $row[1];
     $c1[] = $row[0];
@@ -832,10 +880,12 @@ function map() {
     $cHit = 'yes';
   }
 
+  $dstquery = $dbpdo->prepare("$dststatement");
+  $dstquery->execute($merged_params);
   // Destination countries and count
   // As we loop through we check to see if we hit a country
   // that we already processed so that we can derive a sum
-  while ($row = mysql_fetch_row($dstr)) {
+  while ($row = $dstquery->fetch(PDO::FETCH_NUM)) {
     $b1[] = $row[0];
     $b2[] = $row[1];
     if ($aHit == 'yes') {
@@ -909,7 +959,11 @@ function map() {
 }
 
 function sensors() {
-  $query = "SELECT net_name AS f1, 
+  // This function gets the list of sensors.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
+  //$query = "SELECT net_name AS f1, 
+  $statement = "SELECT net_name AS f1, 
     hostname AS f2,
     agent_type AS f3,
     sensor.sid AS f4
@@ -917,26 +971,44 @@ function sensors() {
     WHERE agent_type != 'pcap' 
     AND active = 'Y'
     ORDER BY net_name ASC";
-
-  $result = mysql_query($query);
-  $rows = array();
-
-  while ($row = mysql_fetch_assoc($result)) {
-    $rows[] = $row;
-  }
+  // debug
+  //error_log("$statement");
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // execute the prepared statement
+  $query->execute();
+  // fetch the data and encode to json
+  $rows = $query->fetchAll(PDO::FETCH_ASSOC);
   $theJSON = json_encode($rows);
   echo $theJSON;
 }
 
 function user_profile() {
+  // This function updates the timezone offset in the user profile.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
   $user = $_SESSION['sUser'];
   $tz = hextostr($_REQUEST['tz']);
   $validtz = "/^(-12:00|-11:00|-10:00|-09:30|-09:00|-08:00|-07:00|-06:00|-05:00|-04:30|-04:00|-03:30|-03:00|-02:00|-01:00|\+00:00|\+01:00|\+02:00|\+03:00|\+03:30|\+04:00|\+04:30|\+05:00|\+05:30|\+05:45|\+06:00|\+06:30|\+07:00|\+08:00|\+08:45|\+09:00|\+09:30|\+10:00|\+10:30|\+11:00|\+11:30|\+12:00|\+12:45|\+13:00|\+14:00)$/";
 
   if (preg_match($validtz, $tz)) { 
-    $query = "UPDATE user_info SET tzoffset = '$tz' WHERE username = '$user'";
-    mysql_query($query);
-    $result = mysql_error();
+    // prepare statement
+    $statement = "UPDATE user_info SET tzoffset = :tz WHERE username = :user";
+    // debug
+    //error_log("$statement");
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // build parameters for prepared statement
+    $params = [":tz" => "$tz", ":user" => "$user"];
+    // execute the prepared statement with the params
+    $query->execute($params);
+    // check for errors
+    $error = $query->errorInfo();
+    $result = "";
+    // if there was no error, then $error[2] should be null
+    if ( ! is_null($error[2]) ) {
+      $result = $error[2];
+    }
     // Update session offset
     $_SESSION['tzoffset'] = $tz;
   } else {
@@ -948,56 +1020,54 @@ function user_profile() {
 }
 
 function summary() {
-  global $when, $sensors;
+  // This function is called when the user clicks the SUMMARY tab.
+  // This function has been updated to use PDO prepared statements.
+
+  global $when, $sensors, $qp2, $qp2_params, $sensor_params, $sv, $dbpdo;
   $limit = $_REQUEST['limit'];
   $qargs = $_REQUEST['qargs'];
   $filter  = hextostr($_REQUEST['filter']);
   list($type,$subtype) = explode("-", $qargs); 
   $oppip = "src";
-  if ($subtype == "src") { $oppip = "dst"; }
-
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      $comment = explode('cmt ', $filter);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid
-        WHERE history.comment = '$comment[1]'";
-    } else {
-      $filter = str_replace('&lt;','<', $filter);
-      $filter = str_replace('&gt;','>', $filter);
-      $filter = "AND " . $filter;
-      $qp2 = "WHERE $when
-        $sensors
-        $filter";
-    }
-  } else {
-    $qp2 = "WHERE $when
-      $sensors";
-  }
+  // subtype is controlled by user, don't trust it
+  $cleansubtype = "";
+  switch ($subtype) {
+  case "src":
+    $cleansubtype = "src";
+    $oppip = "dst";
+    break;
+  case "dst":
+    $cleansubtype = "dst";
+    break;
+  case "sig":
+    $cleansubtype = "sig";
+    break;
+  } 
 
   switch ($type) {
   case "ip":
-    $query = "SELECT COUNT(event.{$subtype}_ip) AS f1,
+    $statement = "SELECT COUNT(event.{$cleansubtype}_ip) AS f1,
       COUNT(DISTINCT(event.signature)) AS f2,
       COUNT(DISTINCT(event.{$oppip}_ip)) AS f3,
-      m{$subtype}.cc AS f4, 
-      m{$subtype}.c_long AS f5,
-      INET_NTOA(event.{$subtype}_ip) AS f6,
-      o{$subtype}.value AS f7 
+      m{$cleansubtype}.cc AS f4, 
+      m{$cleansubtype}.c_long AS f5,
+      INET_NTOA(event.{$cleansubtype}_ip) AS f6,
+      o{$cleansubtype}.value AS f7 
       FROM event
       LEFT JOIN mappings AS msrc ON event.src_ip = msrc.ip
       LEFT JOIN mappings AS mdst ON event.dst_ip = mdst.ip
-      LEFT JOIN object_mappings AS o{$subtype} ON event.{$subtype}_ip = o{$subtype}.object 
-      AND o{$subtype}.type = 'ip_c'
+      LEFT JOIN object_mappings AS o{$cleansubtype} ON event.{$cleansubtype}_ip = o{$cleansubtype}.object 
+      AND o{$cleansubtype}.type = 'ip_c'
       $qp2
       GROUP BY f6
       ORDER BY f1 DESC";
     break;
   case "pt":
-    $query = "SELECT COUNT(event.{$subtype}_port) AS f1,
+    $statement = "SELECT COUNT(event.{$cleansubtype}_port) AS f1,
       COUNT(DISTINCT(event.signature)) AS f2,
       COUNT(DISTINCT(event.src_ip)) AS f3,
       COUNT(DISTINCT(event.dst_ip)) AS f4,
-      event.{$subtype}_port AS f5
+      event.{$cleansubtype}_port AS f5
       FROM event
       LEFT JOIN mappings AS msrc ON event.src_ip = msrc.ip
       LEFT JOIN mappings AS mdst ON event.dst_ip = mdst.ip
@@ -1006,7 +1076,7 @@ function summary() {
       ORDER BY f1 DESC";
     break;
   case "sig":
-    $query = "SELECT COUNT(event.signature) AS f1,
+    $statement = "SELECT COUNT(event.signature) AS f1,
       COUNT(DISTINCT(event.src_ip)) AS f2,
       COUNT(DISTINCT(event.dst_ip)) AS f3,
       event.signature_id AS f4,
@@ -1019,64 +1089,62 @@ function summary() {
       ORDER BY f1 DESC";
     break;
   case "cc":
-    $query = "SELECT COUNT(event.{$subtype}_ip) AS f1,
+    $statement = "SELECT COUNT(event.{$cleansubtype}_ip) AS f1,
       COUNT(DISTINCT(event.signature)) AS f2,
       COUNT(DISTINCT(event.{$oppip}_ip)) AS f3,
-      m{$subtype}.cc AS f4,
-      m{$subtype}.c_long AS f5,
-      COUNT(DISTINCT(event.{$subtype}_ip)) AS f6
+      m{$cleansubtype}.cc AS f4,
+      m{$cleansubtype}.c_long AS f5,
+      COUNT(DISTINCT(event.{$cleansubtype}_ip)) AS f6
       FROM event
       LEFT JOIN mappings AS msrc ON event.src_ip = msrc.ip
       LEFT JOIN mappings AS mdst ON event.dst_ip = mdst.ip
       $qp2
-      AND event.{$subtype}_ip NOT BETWEEN 167772160 AND 184549375
-      AND event.{$subtype}_ip NOT BETWEEN 2886729728 AND 2886795263 
-      AND event.{$subtype}_ip NOT BETWEEN 3232235520 AND 3232301055
-      AND m{$subtype}.cc IS NOT NULL GROUP BY m{$subtype}.cc ORDER BY f1 DESC"; 
+      AND event.{$cleansubtype}_ip NOT BETWEEN 167772160 AND 184549375
+      AND event.{$cleansubtype}_ip NOT BETWEEN 2886729728 AND 2886795263 
+      AND event.{$cleansubtype}_ip NOT BETWEEN 3232235520 AND 3232301055
+      AND m{$cleansubtype}.cc IS NOT NULL GROUP BY m{$cleansubtype}.cc ORDER BY f1 DESC"; 
     break; 
   }
-  $result = mysql_query($query);
+
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // merge params
+  $merged_params = array_merge($sensor_params, $qp2_params);
+  // debug
+  //error_log("statement: $statement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $query->execute($merged_params);
+
   $rows = array();
   $i = 0;
   $n = 0;
-  $r = mysql_num_rows($result);
-  while ($row = mysql_fetch_assoc($result)) {
+  // unbuffered query can't do rowCount, replacing with $i below
+  //$r = $query->rowCount();
+
+  # iterate through each row of the filter table
+  while ($row = $query->fetch(PDO::FETCH_ASSOC)) {
     $n += $row["f1"];
     $i++;
     if ($i <= $limit) $rows[] = $row; 
   }
-  $rows[] = array("n" => $n, "r" => $r);
+  $rows[] = array("n" => $n, "r" => $i);
   $theJSON = json_encode($rows);
   echo $theJSON;     
 }
 
 function view() {
-  global $when, $sensors;
+  // This function is called when the user clicks the VIEWS tab.
+  // This function has been updated to use PDO prepared statements.
+
+  global $when, $sensors, $qp2, $qp2_params, $sensor_params, $sv, $dbpdo;
   $qargs   = $_REQUEST['qargs'];
   $filter  = hextostr($_REQUEST['filter']);
   list($type,$subtype) = explode("-", $qargs);
 
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      $comment = explode('cmt ', $filter);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid
-        WHERE history.comment = '$comment[1]'";
-    } else {
-      $filter = str_replace('&lt;','<', $filter);
-      $filter = str_replace('&gt;','>', $filter);
-      $filter = "AND " . $filter;
-      $qp2 = "WHERE $when
-        $sensors
-        $filter";
-    }
-  } else {
-    $qp2 = "WHERE $when
-      $sensors";
-  }
-
   switch ($type) {
   case "ip":
-    $query = "SELECT CONCAT_WS('|', INET_NTOA(event.src_ip), msrc.cc, msrc.c_long) AS source,
+    $statement = "SELECT CONCAT_WS('|', INET_NTOA(event.src_ip), msrc.cc, msrc.c_long) AS source,
       CONCAT_WS('|', INET_NTOA(event.dst_ip), mdst.cc, mdst.c_long) AS target,
       COUNT(event.src_ip) AS value
       FROM event
@@ -1087,7 +1155,7 @@ function view() {
       GROUP BY source,target";
     break;
   case "ips":
-    $query = "SELECT CONCAT_WS('|', INET_NTOA(event.src_ip), msrc.cc, msrc.c_long) AS source,
+    $statement = "SELECT CONCAT_WS('|', INET_NTOA(event.src_ip), msrc.cc, msrc.c_long) AS source,
       event.signature AS sig,
       CONCAT_WS('|', INET_NTOA(event.dst_ip), mdst.cc, mdst.c_long) AS target,
       COUNT(event.src_ip) AS value
@@ -1099,7 +1167,7 @@ function view() {
       GROUP BY source,target";
     break;
   case "sc":
-    $query = "SELECT CONCAT_WS('|' ,msrc.c_long, msrc.cc) AS source,
+    $statement = "SELECT CONCAT_WS('|' ,msrc.c_long, msrc.cc) AS source,
       CONCAT_WS('|',INET_NTOA(event.dst_ip), mdst.cc) AS target,
       COUNT(event.src_ip) AS value
       FROM event
@@ -1113,7 +1181,7 @@ function view() {
       GROUP BY source,target";
     break;   
   case "dc":
-    $query = "SELECT CONCAT_WS('|', INET_NTOA(event.src_ip), msrc.cc) AS source,
+    $statement = "SELECT CONCAT_WS('|', INET_NTOA(event.src_ip), msrc.cc) AS source,
       CONCAT_WS('|', mdst.c_long, mdst.cc) AS target,
       COUNT(event.dst_ip) AS value
       FROM event
@@ -1127,18 +1195,23 @@ function view() {
       GROUP BY source,target";
     break;    
   }
-  $result = mysql_query($query);
-  $rc = mysql_num_rows($result);
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // merge params
+  $merged_params = array_merge($sensor_params, $qp2_params);
+  // debug
+  //error_log("statement: $statement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $query->execute($merged_params);
+
+  // unbuffered query can't do rowCount, replacing with $records below
+  //$rc = $query->rowCount();
   $records = 0;
   $rows = $srcs = $tgts = $vals = $skip = $names = $_names = array();
-
-  if ($rc == 0) { 
-    $theJSON = json_encode(array("nodes" => $names, "links" => $rows, "records" => $records));
-    echo $theJSON;
-    exit();
-  }  
-
-  while ($row = mysql_fetch_assoc($result)) {
+/*
+*/
+  while ($row = $query->fetch(PDO::FETCH_ASSOC)) {
     if ($type == "ips") {
       $srcs[] = $row["source"]; 
       $tgts[] = $row["sig"];
@@ -1154,6 +1227,12 @@ function view() {
     $sads[] = 0;
     $records++; 
   }
+
+  if ($records == 0) { 
+    $theJSON = json_encode(array("nodes" => $names, "links" => $rows, "records" => $records));
+    echo $theJSON;
+    exit();
+  }  
   // Value counts
   $src_c = array_count_values($srcs);
   $tgt_c = array_count_values($tgts);
@@ -1163,33 +1242,33 @@ function view() {
   foreach ($srcs as $index => $src) {
     // Find the target
     if (in_array($index, $skip)) { continue; }
-  $tgt = $tgts[$index];
-  // Find the keys for all instances of the target as a source
-  $tgt_keys = array_keys($srcs,$tgt);
-  // Now see if any have the source as a target
-  foreach ($tgt_keys as $pos) {
-    if ($tgts[$pos] == $src) {
-      $sads_val = $vals[$pos];
-      unset($srcs[$pos]);
-      unset($tgts[$pos]);
-      unset($vals[$pos]);
-      unset($sads[$pos]);
-      // Add offset to be skipped
-      $skip[] = $pos;
-      // By setting this we flag that this source is also a target
-      $sads[$index] = $sads_val; 
+    $tgt = $tgts[$index];
+    // Find the keys for all instances of the target as a source
+    $tgt_keys = array_keys($srcs,$tgt);
+    // Now see if any have the source as a target
+    foreach ($tgt_keys as $pos) {
+      if ($tgts[$pos] == $src) {
+        $sads_val = $vals[$pos];
+        unset($srcs[$pos]);
+        unset($tgts[$pos]);
+        unset($vals[$pos]);
+        unset($sads[$pos]);
+        // Add offset to be skipped
+        $skip[] = $pos;
+        // By setting this we flag that this source is also a target
+        $sads[$index] = $sads_val; 
+      }
     }
-  }
 
-  // If there is no filter, remove 1:1s with a count of 1
-  if ($filter == 'empty') {
-    if ($vals[$index] == 1 && $sads[$index] == 0 && $src_c[$src] == 1) {
-      unset($srcs[$index]);
-      unset($tgts[$index]);
-      unset($vals[$index]);
-      unset($sads[$index]);
-    }
-  } 
+    // If there is no filter, remove 1:1s with a count of 1
+    if ($filter == 'empty') {
+      if ( isset($vals[$index]) && $vals[$index] == 1 && isset($sads[$index]) && $sads[$index] == 0 && isset($src_c[$src]) && $src_c[$src] == 1) {
+        unset($srcs[$index]);
+        unset($tgts[$index]);
+        unset($vals[$index]);
+        unset($sads[$index]);
+      }
+    } 
   }       
 
   // We have probably truncated these so realign the indexes
@@ -1234,29 +1313,34 @@ function view() {
 }
 
 function autocat() {
+  // This function queries and updates sguild's list of autocats.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
   $usr    = $_SESSION['sUser'];
   $pwd    = $_SESSION['sPass'];
   $offset = $_SESSION['tzoffset'];
-  $mode   = mysql_real_escape_string($_REQUEST['mode']);
+  $mode   = $_REQUEST['mode'];
 
   switch ($mode) {
   case "query"  : 
-    $query = "SELECT autoid, CONVERT_TZ(erase,'+00:00','$offset') AS erase, sensorname, 
+    // build statement
+    $statement = "SELECT autoid, CONVERT_TZ(erase,'+00:00', :offset1) AS erase, sensorname, 
       src_ip, src_port, dst_ip, dst_port, ip_proto,
-      signature, status, active, CONVERT_TZ(timestamp,'+00:00','$offset') AS ts,
+      signature, status, active, CONVERT_TZ(timestamp,'+00:00', :offset2) AS ts,
       u.username AS user, comment
       FROM autocat
       LEFT JOIN user_info AS u ON autocat.uid = u.uid
       ORDER BY ts DESC";
-
-    $result = mysql_query($query);
-
-    $rows = array();
-
-    while ($row = mysql_fetch_assoc($result)) {
-      $rows[] = $row;
-    }
-
+    // debug
+    //error_log("$statement");
+    // prepare statement
+    $query = $dbpdo->prepare("$statement");
+    // build parameters for prepared statement
+    $params = [":offset1" => "$offset", ":offset2" => "$offset"];
+    // execute the prepared statement with the params
+    $query->execute($params);
+    // fetch the data and encode to json
+    $rows = $query->fetchAll(PDO::FETCH_ASSOC);
     $theJSON = json_encode($rows); 
     break;
 
@@ -1323,10 +1407,22 @@ function autocat() {
     }
 
     if ($rm == 1) {
-      $query = "DELETE FROM autocat WHERE autoid = $id";
+      $statement = "DELETE FROM autocat WHERE autoid = :id";
+      // debug
+      //error_log("$statement");
+      // prepare statement
+      $query = $dbpdo->prepare("$statement");
+      // build parameters for prepared statement
+      $params = [":id" => "$id"];
+      // execute the prepared statement with the params
+      $query->execute($params);
+      $result = $query->errorInfo();
+      $err = "";
+      // if there was no error, then $result[2] should be null
+      if ( ! is_null($result[2]) ) {
+        $err = $result[2];
+      }
 
-      mysql_query($query);
-      $err = mysql_error();
     }
 
     $result = array("dbg" => htmlspecialchars($debug),
@@ -1416,11 +1512,13 @@ echo $theJSON;
 }
 
 function addremoveobject() {   
-  $user   = $_SESSION['sUser'];
-  $obtype = mysql_real_escape_string($_REQUEST['obtype']);
-  $object = mysql_real_escape_string(hextostr($_REQUEST['object'])); 
-  $value  = mysql_real_escape_string($_REQUEST['value']);
-  $op     = mysql_real_escape_string($_REQUEST['op']);
+  // This function adds objects to and removes objects from the object_mappings table.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
+  $obtype = $_REQUEST['obtype'];
+  $object = hextostr($_REQUEST['object']); 
+  $value  = $_REQUEST['value'];
+  $op     = $_REQUEST['op'];
 
   // For everything but tags we want to replace the existing value
   $hash = md5($obtype . $object);    
@@ -1434,48 +1532,70 @@ function addremoveobject() {
     break; 
   }
 
+  // Are we adding or removing?
   switch ($op) {
   case "add":
-    $query = "INSERT INTO object_mappings (type,object,value,hash)
-      VALUES ('$obtype','$object','$value','$hash')
+    // If adding object, insert into table.
+    $statement = "INSERT INTO object_mappings (type,object,value,hash)
+      VALUES (:obtype1,:object1,:value1,:hash1)
       ON DUPLICATE KEY UPDATE 
-      type='$obtype',object='$object',value='$value',hash='$hash'";
+      type=:obtype2,object=:object2,value=:value2,hash=:hash2";
+    // build parameters for prepared statement
+    $params = [":obtype1" => "$obtype", ":object1" => "$object", ":value1" => "$value", ":hash1" => "$hash", ":obtype2" => "$obtype", ":object2" => "$object", ":value2" => "$value", ":hash2" => "$hash"];
     break;
   case "rm":
-    $query = "DELETE FROM object_mappings WHERE hash = '$hash'";
+    // If removing object, delete from table.
+    $statement = "DELETE FROM object_mappings WHERE hash = :hash";
+    // build parameters for prepared statement
+    $params = [":hash" => "$hash"];
     break;
   }                
-
-  mysql_query($query);
-  $result = mysql_error();
-  $return = array("msg" => $result);
-
+  // debug
+  //error_log("$statement");
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // execute the prepared statement with the params
+  $query->execute($params);
+  // check for errors
+  $result = $query->errorInfo();
+  $error = "";
+  // if there was no error, then $result[2] should be null
+  if ( ! is_null($result[2]) ) { 
+    $error = $result[2];
+  }
+  $return = array("msg" => $error);
   $theJSON = json_encode($return); 
   echo $theJSON;
 }
 
 function getcolour() {   
-  $user   = $_SESSION['sUser'];
-
-  $query = "SELECT object, value AS colour
+  // This function gets the color mappings from the object_mappings table.
+  // This function has been updated to use PDO prepared statements.
+  global $dbpdo;
+  // build statement
+  $statement = "SELECT object, value AS colour
     FROM object_mappings
     WHERE type = 'el_c'"; 
-
-  $result = mysql_query($query);
-  $rows = array();
-  while ($row = mysql_fetch_assoc($result)) {
-    $rows[] = $row;
-  }
+  // debug
+  //error_log("$statement");
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // execute the prepared statement
+  $query->execute();
+  // fetch the data and encode to json
+  $rows = $query->fetchAll(PDO::FETCH_ASSOC);
   $theJSON = json_encode($rows);
   echo $theJSON;
 }
 
 function objhistory () {
-  global $offset, $start, $sdate;
+  // This function returns the history for an object over the last 7 days.
+  // This function has been updated to use PDO prepared statements.
+  global $offset, $start, $sdate, $sdatetime, $offset, $dbpdo;
   $object = hextostr($_REQUEST['object']);
   $object = str_replace("aa", "", $object);
 
-  // Plant, animal or mineral?  
+  // Is object an IP address?
   $re = '/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/';
   $obtype = 0;
   if (preg_match($re, $object)) {
@@ -1483,45 +1603,66 @@ function objhistory () {
   }
 
   switch ($obtype) {
-  case 0: $subject = "signature_id = '$object'"; break;
-  case 1: $subject = "(src_ip = INET_ATON('$object') OR dst_ip = INET_ATON('$object'))"; break;
-  } 
+  case 0: 
+    $subject = "signature_id = :object"; 
+    $statement = "SELECT
+      DATE(CONVERT_TZ(event.timestamp,'+00:00', :offset1)) AS day,
+      HOUR(CONVERT_TZ(event.timestamp,'+00:00', :offset2)) AS hour,
+      COUNT(event.timestamp) AS value
+      FROM event 
+      WHERE event.timestamp BETWEEN CONVERT_TZ(:sdatetime1,:offset3,'+00:00') - INTERVAL 6 DAY AND CONVERT_TZ(:sdatetime2,:offset4,'+00:00') + INTERVAL 1 DAY 
+      AND signature_id = :object
+      GROUP BY day,hour
+      ORDER BY day ASC";
+    $params = [":offset1" => "$offset", ":offset2" => "$offset", ":sdatetime1" => "$sdatetime", ":offset3" => "$offset", ":sdatetime2" => "$sdatetime", ":offset4" => "$offset", ":object" => "$object"];
+  break;
 
-  $query = "SELECT
-    DATE(CONVERT_TZ(event.timestamp,'+00:00','$offset')) AS day,
-      HOUR(CONVERT_TZ(event.timestamp,'+00:00','$offset')) AS hour,
+  case 1: 
+    $subject = "(src_ip = INET_ATON('$object') OR dst_ip = INET_ATON('$object'))"; 
+    $statement = "SELECT
+      DATE(CONVERT_TZ(event.timestamp,'+00:00', :offset1)) AS day,
+      HOUR(CONVERT_TZ(event.timestamp,'+00:00', :offset2)) AS hour,
       COUNT(event.timestamp) AS value
       FROM event 
-      WHERE event.timestamp BETWEEN $start - INTERVAL 6 DAY AND $start + INTERVAL 1 DAY 
-      AND $subject
+      WHERE event.timestamp BETWEEN CONVERT_TZ(:sdatetime1,:offset3,'+00:00') - INTERVAL 6 DAY AND CONVERT_TZ(:sdatetime2,:offset4,'+00:00') + INTERVAL 1 DAY 
+      AND (src_ip = INET_ATON(:object1) OR dst_ip = INET_ATON(:object2))
       GROUP BY day,hour
       ORDER BY day ASC";
+    $params = [":offset1" => "$offset", ":offset2" => "$offset", ":sdatetime1" => "$sdatetime", ":offset3" => "$offset", ":sdatetime2" => "$sdatetime", ":offset4" => "$offset", ":object1" => "$object", ":object2" => "$object"];
+  break;
+  } 
+  $query = $dbpdo->prepare("$statement");
+  // original used unbuffered query, but that doesn't seem to work with PDO?
+  //$result = mysql_unbuffered_query($query);
+  //$query->setAttribute( PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, False );
+  $query->execute(array_merge($params));
 
   $rows1 = $rows2 = array(); 
   $r1 = $r2 = 0;
-
-  $result = mysql_unbuffered_query($query);
-
-  while ($row = mysql_fetch_assoc($result)) {
+  while ($row = $query->fetch(PDO::FETCH_ASSOC)) {
     $rows1[] = $row;
     $r1++;
   }
-
   $result = "";
 
   if ($r1 != 0 && $obtype == 1) {
-    $query = "SELECT
+    $statement = "SELECT
       COUNT(signature_id) AS value,
         signature AS label,
         signature_id AS sid
         FROM event
-        WHERE event.timestamp BETWEEN $start - INTERVAL 6 DAY AND $start + INTERVAL 1 DAY
-        AND $subject
+        WHERE event.timestamp BETWEEN CONVERT_TZ(:sdatetime1,:offset1,'+00:00') - INTERVAL 6 DAY AND CONVERT_TZ(:sdatetime2,:offset2,'+00:00') + INTERVAL 1 DAY
+        AND (src_ip = INET_ATON(:object1) OR dst_ip = INET_ATON(:object2))
         GROUP BY signature_id
         ORDER BY value DESC";
 
-    $result = mysql_unbuffered_query($query); 
-    while ($row = mysql_fetch_assoc($result)) {
+    $params = [":sdatetime1" => "$sdatetime", ":offset1" => "$offset", ":sdatetime2" => "$sdatetime", ":offset2" => "$offset", ":object1" => "$object", ":object2" => "$object"];
+  // original used unbuffered query, but that doesn't seem to work with PDO?
+  //$result = mysql_unbuffered_query($query);
+  //$query->setAttribute( PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, False );
+  $query = $dbpdo->prepare("$statement");
+  $query->execute(array_merge($params));
+  while ($row = $query->fetch(PDO::FETCH_ASSOC)) {
       $rows2[] = $row;
       $r2++;
     }
@@ -1532,30 +1673,12 @@ function objhistory () {
 }
 
 function times() {   
-  global $offset, $when, $sensors;
-  $filter = hextostr($_REQUEST['filter']);
-  if ($filter != 'empty') {
-    if (substr($filter, 0,4) == 'cmt ') {
-      $comment = explode('cmt ', $filter);
-      $qp2 = "LEFT JOIN history ON event.sid = history.sid AND event.cid = history.cid 
-        WHERE history.comment = '" . mysql_real_escape_string($comment[1]) . "'
-        AND $when $sensors";
-    } else {
-      // this needs to be fixed
-    $filter = str_replace('&lt;','<', $filter);
-    $filter = str_replace('&gt;','>', $filter);
-    $filter = "AND " . $filter;
-    $qp2 = "WHERE $when
-      $sensors
-      $filter";
-    }
-  } else {
-    $qp2 = "WHERE $when
-      $sensors";
-  }
+  // This function returns data to the times visualization on the EVENTS tab.
+  // This function has been updated to use PDO prepared statements.
 
-  $query = "SELECT
-    SUBSTRING(CONVERT_TZ(event.timestamp,'+00:00','$offset'),12,5) AS time,
+  global $offset, $when, $sensors, $qp2, $qp2_params, $sensor_params, $sv, $dbpdo;
+  $statement = "SELECT
+    SUBSTRING(CONVERT_TZ(event.timestamp,'+00:00',:substringoffset),12,5) AS time,
       COUNT(signature) AS count 
       FROM event
       LEFT JOIN mappings AS msrc ON event.src_ip = msrc.ip
@@ -1563,11 +1686,22 @@ function times() {
       $qp2
       GROUP BY time 
       ORDER BY event.timestamp";
-  $result = mysql_query($query);
+  // add params for local part of statement
+  $local_params[':substringoffset'] = "$offset";
+  // prepare statement
+  $query = $dbpdo->prepare("$statement");
+  // merge params
+  $merged_params = array_merge($local_params, $sensor_params, $qp2_params);
+  // debug
+  //error_log("statement: $statement");
+  //error_log("merged_params: " . print_r($merged_params,1));
+  // execute the prepared statement with the params
+  $query->execute($merged_params);
+
   $rows = array();
   $r = $m = 0;
 
-  while ($row = mysql_fetch_assoc($result)) {
+  while ($row = $query->fetch(PDO::FETCH_ASSOC)) {
     $rows[] = $row;
     $cnts[] = $row['count'];
     $r++;
--- securityonion-squert-20161212.orig/.scripts/securityonion_update.sql
+++ securityonion-squert-20161212/.scripts/securityonion_update.sql
@@ -133,6 +133,8 @@ VALUES ('url','','1','4d616c77617265446f
 
 GRANT INSERT,UPDATE,DELETE ON filters TO 'readonly'@'localhost';
 
+GRANT DELETE on autocat to 'readonly'@'localhost';
+
 GRANT DELETE on history to 'readonly'@'localhost';
 
 GRANT UPDATE on user_info TO 'readonly'@'localhost';
